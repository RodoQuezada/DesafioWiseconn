'use strict';
var inherits = require('util').inherits;
var EventEmitter = require('events').EventEmitter;
var once = require('./util/once').once;
var Decimal = require('decimal.js');

function Characteristic(displayName, UUID, props) {
  this.displayName = displayName;
  this.UUID = UUID;
  this.iid = null;
  this.value = null;
  this.status = null;
  this.eventOnlyCharacteristic = false;
  this.props = props || {
    format: null,
    unit: null,
    minValue: null,
    maxValue: null,
    minStep: null,
    perms: []
  };

  this.subscriptions = 0;
}

inherits(Characteristic, EventEmitter);

Characteristic.Formats = {
  BOOL: 'bool',
  INT: 'int',
  FLOAT: 'float',
  STRING: 'string',
  UINT8: 'uint8',
  UINT16: 'uint16',
  UINT32: 'uint32',
  UINT64: 'uint64',
  DATA: 'data',
  TLV8: 'tlv8',
  ARRAY: 'array',
  DICTIONARY: 'dictionary'
}

Characteristic.Units = {
  CELSIUS: 'celsius',
  PERCENTAGE: 'percentage',
  ARC_DEGREE: 'arcdegrees',
  LUX: 'lux',
  SECONDS: 'seconds'
}

Characteristic.Perms = {
  READ: 'pr',
  PAIRED_READ: 'pr',
  WRITE: 'pw',
  PAIRED_WRITE: 'pw',
  NOTIFY: 'ev',
  EVENTS: 'ev',
  ADDITIONAL_AUTHORIZATION: 'aa',
  TIMED_WRITE: 'tw',
  HIDDEN: 'hd'
}

Characteristic.prototype.setProps = function(props) {
  for (var key in (props || {}))
    if (Object.prototype.hasOwnProperty.call(props, key))
      this.props[key] = props[key];
  return this;
}


Characteristic.prototype.subscribe = function () {
  if (this.subscriptions === 0) {
    this.emit('subscribe');
  }
  this.subscriptions++;
}

Characteristic.prototype.unsubscribe = function() {
  var wasOne = this.subscriptions === 1;
  this.subscriptions--;
  this.subscriptions = Math.max(this.subscriptions, 0);
  if (wasOne) {
    this.emit('unsubscribe');
  }
}

Characteristic.prototype.getValue = function(callback, context, connectionID) {
  if (this.eventOnlyCharacteristic === true) {
    if (callback) {
      callback(null, null);
    }

    return;
  }

  if (this.listeners('get').length > 0) {
    this.emit('get', once(function(err, newValue) {
      this.status = err;
      if (err) {
        if (callback) callback(err);
      }
      else {
        newValue = this.validateValue(newValue);
        if (newValue === undefined || newValue === null)
          newValue = this.getDefaultValue();
        var oldValue = this.value;
        this.value = newValue;
        if (callback) callback(null, newValue);
        if (oldValue !== newValue)
          this.emit('change', { oldValue:oldValue, newValue:newValue, context:context });
      }

    }.bind(this)), context, connectionID);
  }
  else {
    if (callback)
      callback(this.status, this.value);
  }
}

Characteristic.prototype.validateValue = function(newValue) {

 var isNumericType = false;
 var minValue_resolved = 0;
 var maxValue_resolved = 0;
 var minStep_resolved = undefined;
 var stepDecimals = 0;

  switch(this.props.format) {
    case 'int':
      minStep_resolved=1;
      minValue_resolved=-2147483648;
      maxValue_resolved=2147483647;
      isNumericType=true;
      break;
    case 'float':
      minStep_resolved=undefined;
      minValue_resolved=undefined;
      maxValue_resolved=undefined;
      isNumericType=true;
      break;
    case 'uint8':
      minStep_resolved=1;
      minValue_resolved=0;
      maxValue_resolved=255;
      isNumericType=true;
      break;
    case 'uint16':
      minStep_resolved=1;
      minValue_resolved=0;
      maxValue_resolved=65535;
      isNumericType=true;
      break;
    case 'uint32':
      minStep_resolved=1;
      minValue_resolved=0;
      maxValue_resolved=4294967295;
      isNumericType=true;
      break;
    case 'uint64':
      minStep_resolved=1;
      minValue_resolved=0;
      maxValue_resolved=18446744073709551615;
      isNumericType=true;
      break;
     case 'bool':
      return (newValue == true);
      break;
    case 'string':
      var myString = newValue || '';
      myString = String(myString);
      var maxLength = this.props.maxLen;
      if (maxLength === undefined) maxLength=64;
      if (myString.length>maxLength) myString = myString.substring(0,maxLength);
      return myString;
      break;
    case 'data':
      var maxLength = this.props.maxDataLen;
      if (maxLength===undefined) maxLength=2097152;
      return newValue;
      break;
    case 'tlv8':
      break;
    default:
      return newValue;
    };

  if (isNumericType) {
    if (isNaN(newValue)) return this.value;
    if (newValue === false) return 0;
    if (newValue === true) return 1;
    if ((!isNaN(this.props.maxValue))&&(this.props.maxValue!==null)) maxValue_resolved=this.props.maxValue;
    if ((!isNaN(this.props.minValue))&&(this.props.minValue!==null)) minValue_resolved=this.props.minValue;
    if ((!isNaN(this.props.minStep))&&(this.props.minStep!==null)) minStep_resolved=this.props.minStep;

    if (newValue<minValue_resolved) newValue = minValue_resolved;
    if (newValue>maxValue_resolved) newValue = maxValue_resolved;
    if (minStep_resolved!==undefined) {
      if (Math.floor(minStep_resolved) === minStep_resolved)
        stepDecimals = 0;
      else
        stepDecimals = minStep_resolved.toString().split(".")[1].length || 0;
      try {
        var decimalVal = new Decimal(newValue);
        var decimalDiff = decimalVal.mod(minStep_resolved);
        decimalVal = decimalVal.minus(decimalDiff);
        if (stepDecimals === 0) {
          newValue = parseInt(decimalVal.toFixed(0));
        } else {
          newValue = parseFloat(decimalVal.toFixed(stepDecimals));
        }
      } catch (e) {
        return this.value;
      }
    }

    if (this['valid-values']!==undefined)
      if (!this['valid-values'].includes(newValue)) return this.value;
    if (this['valid-values-range']!==undefined) {
      if (newValue<this['valid-values-range'][0]) newValue=this['valid-values-range'][0];
      if (newValue>this['valid-values-range'][1]) newValue=this['valid-values-range'][1];
    }
  }
  return newValue;
}

Characteristic.prototype.setValue = function(newValue, callback, context, connectionID) {

  if ( newValue instanceof Error ) {
    this.status = newValue
  } else {
    this.status = null;
  }

  newValue = this.validateValue(newValue);

  if (this.listeners('set').length > 0) {
    this.emit('set', newValue, once(function(err) {
      this.status = err;
      if (err) {
        if (callback) callback(err);
      }
      else {
        if (newValue === undefined || newValue === null)
          newValue = this.getDefaultValue();
        var oldValue = this.value;
        this.value = newValue;
        if (callback) callback();

        if (this.eventOnlyCharacteristic === true || oldValue !== newValue)
          this.emit('change', { oldValue:oldValue, newValue:newValue, context:context });
      }

    }.bind(this)), context, connectionID);

  }
  else {
    if (newValue === undefined || newValue === null)
      newValue = this.getDefaultValue();
    var oldValue = this.value;
    this.value = newValue;
    if (callback) callback();

    if (this.eventOnlyCharacteristic === true || oldValue !== newValue)
      this.emit('change', { oldValue:oldValue, newValue:newValue, context:context });
  }

  return this;
}

Characteristic.prototype.updateValue = function(newValue, callback, context) {

  if ( newValue instanceof Error ) {
    this.status = newValue
  } else {
    this.status = null;
  }

  newValue = this.validateValue(newValue);

  if (newValue === undefined || newValue === null)
    newValue = this.getDefaultValue();
  var oldValue = this.value;
  this.value = newValue;
  if (callback) callback();

  if (this.eventOnlyCharacteristic === true || oldValue !== newValue)
    this.emit('change', { oldValue:oldValue, newValue:newValue, context:context });
  return this;
}

Characteristic.prototype.getDefaultValue = function() {
  switch (this.props.format) {
    case Characteristic.Formats.BOOL: return false;
    case Characteristic.Formats.STRING: return "";
    case Characteristic.Formats.DATA: return null;
    case Characteristic.Formats.TLV8: return null;
    default: return this.props.minValue || 0;
  }
}

Characteristic.prototype._assignID = function(identifierCache, accessoryName, serviceUUID, serviceSubtype) {
  this.iid = identifierCache.getIID(accessoryName, serviceUUID, serviceSubtype, this.UUID);
}

Characteristic.prototype.toHAP = function(opt) {
  var value = this.value;
  if (this.props.minValue != null && value < this.props.minValue) value = this.props.minValue;
  if (this.props.maxValue != null && value > this.props.maxValue) value = this.props.maxValue;
  if (this.props.format != null) {
    if (this.props.format === Characteristic.Formats.INT)
      value = parseInt(value);
    else if (this.props.format === Characteristic.Formats.UINT8)
      value = parseInt(value);
    else if (this.props.format === Characteristic.Formats.UINT16)
      value = parseInt(value);
    else if (this.props.format === Characteristic.Formats.UINT32)
      value = parseInt(value);
    else if (this.props.format === Characteristic.Formats.UINT64)
      value = parseInt(value);
    else if (this.props.format === Characteristic.Formats.FLOAT) {
      value = parseFloat(value);
      if (this.props.minStep != null) {
        var pow = Math.pow(10, decimalPlaces(this.props.minStep));
        value = Math.round(value * pow) / pow;
      }
    }
  }

  if (this.eventOnlyCharacteristic === true) {
    value = null;
  }

  var hap = {
    iid: this.iid,
    type: this.UUID,
    perms: this.props.perms,
    format: this.props.format,
    value: value,
    description: this.displayName
  };

  if (this.props.validValues != null && this.props.validValues.length > 0) {
    hap['valid-values'] = this.props.validValues;
  }

  if (this.props.validValueRanges != null && this.props.validValueRanges.length > 0 && !(this.props.validValueRanges.length & 1)) {
    hap['valid-values-range'] = this.props.validValueRanges;
  }

  if (this.props.unit != null) hap.unit = this.props.unit;
  if (this.props.maxValue != null) hap.maxValue = this.props.maxValue;
  if (this.props.minValue != null) hap.minValue = this.props.minValue;
  if (this.props.minStep != null) hap.minStep = this.props.minStep;
  if (this.props.format === Characteristic.Formats.STRING) {
    var str = new Buffer(value, 'utf8'),
        len = str.byteLength;
    if (len > 256) {
      hap.value = str.toString('utf8', 0, 256);
      hap.maxLen = 256;
    } else if (len > 64) {
      hap.maxLen = len;
    }
  }

  if (this.props.perms.indexOf(Characteristic.Perms.READ) == -1)
    delete hap.value;

  if (opt && opt.omitValues)
    delete hap.value;

  return hap;
}

function decimalPlaces(num) {
  var match = (''+num).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
  if (!match) { return 0; }
  return Math.max(
       0,
       (match[1] ? match[1].length : 0)
       - (match[2] ? +match[2] : 0));
}

module.exports = {
  Characteristic: Characteristic
};